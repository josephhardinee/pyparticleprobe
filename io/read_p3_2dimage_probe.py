"""
pyparticleprobe.io.read_p3_2dimage_probe
=========================

A grouping of scripts designed to read in various file formats containing data
 from 2-D precipitation and cloud imaging probes (PIP and CIP) aboard 
 the NOAA WP-3D aircraft.

Created by Nick Guy.

"""
# HISTORY::
#   8 Jan 2014 - Nick Guy.   NRC, NOAA/NSSL (nick.guy@noaa.gov)   
#                Converted NCL functions below to Python
#  19 Mar 2014 - NG: Added functionality for processing UCSC netcdf
# FUNCTIONS::
# rab_netcdf_vars - Pulls out a number of variables from NetCDF file created
#                   using R Black results.
# ucsc_netcdf_vars - Pulls out variables from UCSC NetCDF file
# ucsc_flt_lev_vars - Pulls out variables from flight level data to complete previous
# rab_netcdf - Opens the R Black NetCDF file
# ucsc_netcdf - Opens the UCSC NetCDF data file
# dbaum_spectrum_ascii - Open the Baumgardner ascii file (Not operable!!!)
#-------------------------------------------------------------------
# Load the needed packages
from scipy.io import FortranFile
import numpy as np
from netCDF4 import Dataset#, num2date, date2num
import netCDF4 as n4
import matplotlib.dates as mdate
import scipy.interpolate as si

import read_p3_flight as p3FltVar
#import general.library as gl
#-------------------------------------------------------------------
# Define various constants that may be used for calculations
#===============================================================
# BEGIN FUNCTIONS
#===============================================================

def rab_netcdf_vars(FilePathString,Subset=False,StartT=None,EndT=None):
    """Read a NetCDF file containing distribution data generated by Bob
   Black at the NOAA AOML.  The original Fortran binary has been converted
   into easier to use NetCDF format.
 INPUT::
  FilePathString  = Long string path to NetCDF file to be read
        OPTIONAL
  Subset          = Set True if subset of data by time is desired
  StartT          = Start time for subsetting [matlab date number instance]
  EndT            = End time for subsetting [matlab date number instance]
 OUTPUT::
  Sizebins        = The mid-point of size bins [um]
  Tm              = Time [in matplotlib number]
  Water           = Water species concentration [m^-3]
  Ice             = Ice species concentration [m^-3]
  Rhoair          = Air density [g/m^3]
  W               = Aircraft vertical velocity [m/s]
 USAGE::
  DatOut = rab_netcdf_vars(filepathString,FillVal)
    """
# HISTORY::
#  13 Feb 2014 - Nick Guy NOAA/NSSL/WRDD, NRC
# NOTES::
#  The original binary files provided concentration data in units of L^-1, 
#   this has been converted to units of m^-3 in the NetCDF files by 
#   the p3pip2nc_rab.ncl function.
#  Time units in the NetCDF are in units of 'seconds since 1970-1-1 00:00:00'
#---------------------------------------
    # Read the NetCDF file
    Data = n4.Dataset(FilePathString,'r')

    # Read the size bins
    Sizebins = Data.variables['Sizebins']
    
    # First pull out the time variable
    Time = mdate.epoch2num(Data.variables['EpochTime'])
        
    # Check whether to subset and the range
    if Subset:
        # Check which type of subsetting to apply
        if SubType.lower() == 'time':
            inSub = (Time >= Smin) & (Time <= Smax) # Indices of time subset
        elif SubType.lower() == 'altitude':
            inSub = (altitude >= Smin) & (altitude <= Smax) # Indices of altitude subset
    else:
        inSub = np.arange(0,len(Time)) # No subset, take entire array
        
    # Pull out the subsetted variables
    Tm = +Time[inSub] # Time
    Water = Data.variables['Water'][inSub,:] # Water conc
    Ice = Data.variables['Ice'][inSub,:]
     
    RhoAir = Data.variables['RhoAir'][inSub]
    W = Data.variables['vertVel'][inSub]
        
    del Time
        
    # Create a dictionary to transfer the data
    data = {'Sizebins' : Sizebins,
            'Time' : Tm,
            'Conc_water' : Water,
            'Conc_ice' : Ice,
            'RhoAir' : RhoAir,
            'w_vel_air' : W}
            
    return data
#====================================================

def ucsc_netcdf_vars(FilePathString,Instr,YYYY,MM,DD,flCDF,
                     Subset=True,SubType=None,Smin=None,Smax=None,
                     AvDat=False,RunAv=6):
    """Read a NetCDF file containing distribution data generated by the
  University of California at Santa Cruz.  Group there is led by 
  Patrick Chuang (pchuang@ucsc.edu).
 INPUT::
  FilePathString  = Long string path to UCSC NetCDF file to be read
  Instr           = Name of instrument to process ('cip' or 'pip' or '')
  YYYY            = String year
  MM              = String month
  DD              = String day
  flCDF           = Long string path to flight level NetCDF file to be read
        OPTIONAL
  Subset          = Set True if subset of data by time is desired
  SubType         = Subset to apply min and max either 'time' or 'altitude'
  Smin            = Start time [matlab date number instance] or lower altitude [float]
                    for subsetting 
  Smax            = End time [matlab date number instance] or upper altitude [float]
                    for subsetting 
  AvDat           = Set True if averaging and data reduction is desired
 OUTPUT::
  Sizebins        = Mid-point size of bin [micron]
  Tm              = Time [matlab date object, fractional day]
  Water           = Concentration of liquid water particles [m^-3]
  RhoAir          = Density of air [kg/m^3]
  W               = Vertical velocity [m/s]
  Alt             = Aircraft altitude [m]
 USAGE::
  Sizebins,Tm,Water,RhoAir,W = ucsc_netcdf_vars(filepathString,Instr,YYYY,MM,DD,flCDF,[**args])
 NOTES::
  The NetCDF from UCSC has data with the following units, some of which are 
   converted in the following program.  
   The Concentration is is provided as cm^-3, and converted to m^-3
     Note the 10 minute buffer required when subsetting the data.  Though the idea would
   remain the same for any function used, this is specific in format to the 
   matplotlib.dates.date2num type object where is days.{fraction of day} since 0001.
    """
# HISTORY::
#  18 Jul 2013 - Nick Guy NOAA/NSSL/WRDD, NRC
#---------------------------------------
    # Read the NetCDF file
    Data = n4.Dataset(FilePathString,'r')
    
    # Read the size bins
    Sizebins = Data.variables[Instr.upper()+'corr_bin_mid'][:]
    Bin_edges = np.hstack((Data.variables[Instr.upper()+'corr_bin_min'][0], \
                          Data.variables[Instr.upper()+'corr_bin_max']))
    
    # First pull out the time variable
    HHMMSS = Data.variables['time']
    
    # Now makes this an "unaware" datetime object converted back into a number
    #  of seconds since beginning of day.  Necessary because of the way the 
    #  variable is saved in NetCDF
    Time = mdate.date2num(n4.num2date(HHMMSS,'seconds since '+YYYY+'-'+MM+'-'+DD+' 00:00:00'))
   
    # Pull in the aircraft variables of interest
    FltTime, Fltrhoair, FltVertW, FltAlt = ucsc_flt_lev_vars(flCDF)
    
    # Map the data from the aircraft variables to the PIP variables
    altitude = si.griddata(FltTime,FltAlt,Time)
    rhoair = si.griddata(FltTime,Fltrhoair,Time)
    VertVel = si.griddata(FltTime,FltVertW,Time)
    
    # Check whether to subset and the range
    if Subset:
        # Check which type of subsetting to apply
        if SubType.lower() == 'time':
            inSub = (Time >= Smin) & (Time <= Smax) # Indices of time subset
        elif SubType.lower() == 'altitude':
            inSub = (altitude >= Smin) & (altitude <= Smax) # Indices of altitude subset
    else:
        inSub = np.arange(0,len(Time)) # No subset, take entire array

    # Pull out the subsetted variables
    Tm = +Time[inSub] # Time
    Water = Data.variables[Instr.upper()+'corr_conc'][:,inSub] * 1E6 # Water conc
    Altitude = altitude[inSub]
    RhoAir = rhoair[inSub]
    W = VertVel[inSub]
    Alt = altitude[inSub]

    del Time,FltTime,Fltrhoair,FltVertW,inSub,rhoair,VertVel
    
    # Create a running average of the data and subset to every RunAv
    if AvDat:
        weights = np.repeat(1.,RunAv)/RunAv
        Tm = np.convolve(Tm,weights,'valid')[::RunAv]
        RhoAir = np.convolve(RhoAir,weights,'valid')[::RunAv]
        W = np.convolve(W,weights,'valid')[::RunAv]
        Alt = np.convolve(Alt,weights,'valid')[::RunAv]
        # Since Water is a 2D
        WatTmp = np.empty([Water.shape[0],Water.shape[1]-RunAv+1])
        for num in range(Water.shape[0]):
            WatTmp[num,:] = np.convolve(Water[num,:],weights,'valid')
        del Water
        Water = WatTmp[:,::RunAv]
        
    # Create a dictionary to transfer the data
    data = {'Sizebins' : Sizebins,
            'Time' : Tm,
            'Conc' : Water.T,
            'RhoAir' : RhoAir,
            'W_vel_air' : W,
            'Altitude' : Alt,
            'Bin_edges' : Bin_edges}

    # Transpose the concentration as they were made with Matlab (column major)
    return data
#====================================================

def ucsc_flt_lev_vars(fname):
    """Read in data from NetCDF file containing P3 flight level data created
  by NOAA AOC.  Pull out the needed variables for flight track info.
 INPUT::
  fname           = Filename [string]
 OUTPUT::
  Time            = Aircraft time array [Datetime object]
  Rhoair          = Air density [kg/m^3]
  VertVel         = Vertical Wind [m/s]
  Altitude        = Aircraft altitude [m]
 USAGE::
  Time,Rhoair,VertVel = ucsc_flt_lev_vars(fname)
 NOTES::
  The variables are masked of bad values
    """
# HISTORY::
#   7 Mar 2014 - Nick Guy NOAA/NSSL/WRDD, NRC
#---------------------------------------------------
    # Set a sea level density value
    sea_level_dens = 1.2250 #[kg/m^3]
    
    # Read the NetCDF
    ncFile = n4.Dataset(fname,'r')

    # Retrieve vertical velocity
#    VertVel = ncFile.variables['WSZ_DPJ'][:]
    VertVel = ncFile.variables['UWZ.1'][:]
    np.ma.masked_invalid(VertVel)
        
    # Retrieve variables to calculate Air density
    Temp = ncFile.variables['TA.1'][:] + 273.15 # Convert from C to K
    np.ma.masked_invalid(Temp)
    Alt = ncFile.variables['AltGPS.3'][:]
    np.ma.masked_invalid(Alt)
    RhoAir = sea_level_dens * np.exp(-0.04 * Alt / Temp)
    del Temp
    
    # Pull out the start time
    StartTime = ncFile.StartTime
    
    # Create a time array 
    TimeSec = np.linspace(StartTime,StartTime + len(RhoAir), len(RhoAir))
    
    Time = mdate.epoch2num(TimeSec)
    
    return Time,RhoAir,VertVel,Alt
#**====================================================

def rab_netcdf(FilePathString):
    """Read a NetCDF file containing distribution data generated by Bob
   Black at the NOAA AOML.  The original Fortran binary has been converted
   into easier to use NetCDF format.
 INPUT::
  FilePathString  = Long string path to NetCDF file to be read
 OUTPUT::
  Data            = Data array containing ascii data
 USAGE::
  DatOut = rab_netcdf(filepathString,FillVal)
    """
# HISTORY::
#  13 Feb 2014 - Nick Guy NOAA/NSSL/WRDD, NRC
#---------------------------------------
    # Read the NetCDF file
    Data = n4.Dataset(FilePathString,'r')

    return Data
#====================================================

def ucsc_netcdf(FilePathString,Instr):
    """Read a NetCDF file containing distribution data generated by the
  University of California at Santa Cruz.  Group there is led by 
  Patrick Chuang (pchuang@ucsc.edu).
 INPUT::
  FilePathString  = Long string path to NetCDF file to be read
  Instr           = Name of instrument to process ('cip' or 'pip')
 OUTPUT::
  Data            = Data array containing ascii data
 USAGE::
  DatOut = ucsc_netcdf(filepathString,FillVal)
 NOTES::
  The NetCDF files were generated by p3_pip_cip_ucsc_ascii2nc.ncl, 
  which read the original ascii files and created a NetCDF containing
  all data, found to be easier for processing.

  This file was constructed when UCSC processed 1D data.  It was later
  learned through conversations with DMT that the 1D data is "useless"
  and that only the 2D image data should be used.  Make sure that 2D data
  has been used to construct 
    """
# MODIFICATION HISTORY::
#  18 Jul 2013 - Nick Guy NOAA/NSSL/WRDD, NRC
#---------------------------------------
    # Read the NetCDF file
    Data = n4.Dataset(FilePathString,'r')

    return Data
#====================================================

def dbaum_spectrum_ascii(FilePathString,Instr,WorI,Missing):
    """Read ASCII files containing distribution data generated by the
  CIP/PIP processing code written by Darrel Baumgardner at DMT.
  (darrel.baumgardner@gmail.com).
 INPUT::
  filepathString  = Long string path to ascii file to be read
  Instr           = String containing instrument name, "cip" or "pip"
  WorI            = String containing which concentration file to use
                    can be set to "water" or "ice"
  FillVal         = Value for missing data
 OUTPUT::
  Data            = Data array containing ascii data
 USAGE::
  DatOut = dbaum_spectrum_ascii(FilePathString,Instr,WorI,FillVal)
 NOTES::
  The CIP instrument (2D-C) has a range of 12.5 micron -1.55 mm with 
   0.025 mm resolution.
  The PIP instrument (2D-P) has a range of 0.100-6.4 mm with 0.100 
   mm resolution

  There are 61 columns in these ascii files. 
  Column 1 = Absolute time in seconds of day (UTC or local depends 
   upon PADS setup.
  Columns 2-61 = Drop concentration in number per Liter, over 60
   bins beginning at 25 micron and increasing by 25 micron each bin.
   Each bin has been averaged over the number of seconds indicated
   in the the initialization file.
  
  A MODIFICATION of the output is necessary to make this script work.
   The first line are column labels, but because the labels start with
   numbers, NCL does not read these corrrectly.  Therefore the column
   label line must be deleted to properly read.
    """
# HISTORY::
#  13 Aug 2013 - Nick Guy NOAA/NSSL/WRDD, NRC Postdoc
#
#   6 Nov 2013 - The readAsciiTable function is now used to read the data
#                This avoids requiring user interaction to manually remove
#                 header information created by ImageProcessor program.
#---------------------------------------
  # Check that "pip" or "cip" is entered
#  if (str_strip(str_lower(Instr)).eq."pip" .or. str_strip(str_lower(Instr)).ne."cip") then
#    print("Need to enter "+quote+"cip"+quote+" or "+quote+"pip"+quote+" for 2nd variable")
#    return
#  end if

  # Check that "water" or "ice" is entered
#  if (str_strip(str_lower(WorI)).eq."ice" .or. str_strip(str_lower(WorI)).ne."water") then
#    print("Need to enter "+quote+"water"+quote+" or "+quote+"ice"+quote+" for 3rd variable")
#    return
#  end if

  # Set filename
    fname=Instr.upper()+WorI.lower()+"Spectra.dat"

  # Read the concentration spectra file
    Data = np.loadtxt(FilePathString+fname,dtype=float,skiprows=1)

  # Convert concentration data from L^-1 to m^-3 (for SI units)
    Data[:,1:60] = Data[:,1:60]*1000.

    return Data
#====================================================

def dbaum_pbp_ascii(FilePathString,Instr,Missing):
    """Read ASCII files containing distribution data generated by the
  CIP/PIP processing code written by Darrel Baumgardner at DMT.
  (darrel.baumgardner@gmail.com).
 INPUT::
  filepathString  = Long string path to ascii file to be read
  Instr           = String containing instrument name, "cip" or "pip"
  FillVal         = Value for missing data
 OUTPUT::
  Data            = Data array containing ascii data
 USAGE::
  DatOut = read_dbaum_pbp_ascii(FilePathString,Instr,FillVal)
 NOTES::
  The CIP instrument (2D-C) has a range of 12.5 micron -1.55 mm with 
   0.025 mm resolution.
  The PIP instrument (2D-P) has a range of 0.100-6.4 mm with 0.100 
   mm resolution

  There are 61 columns in these ascii files. 
  Column 1 = Absolute time in seconds of day (UTC or local depends 
   upon PADS setup.
  Columns 2-61 = Drop concentration in number per Liter, over 60
   bins beginning at 25 micron and increasing by 25 micron each bin.
   Each bin has been averaged over the number of seconds indicated
   in the the initialization file.
  
  A MODIFICATION of the output is necessary to make this script work.
   The first line are column labels, but because the labels start with
   numbers, NCL does not read these corrrectly.  Therefore the column
   label line must be deleted to properly read.
    """
# MODIFICATION HISTORY::
#  13 Aug 2013 - Nick Guy NOAA/NSSL/WRDD, NRC Postdoc
#---------------------------------------
    # Check that "pip" or "cip" is entered
    #  if (str_strip(str_lower(Instr)).eq."pip" .or. str_strip(str_lower(Instr)).ne."cip") then
    #    print("Need to enter "+quote+"cip"+quote+" or "+quote+"pip"+quote+" for 2nd variable")
    #    return
    #  end if

    # Check that "water" or "ice" is entered
    #  if (str_strip(str_lower(WorI)).eq."ice" .or. str_strip(str_lower(WorI)).ne."water") then
    #    print("Need to enter "+quote+"water"+quote+" or "+quote+"ice"+quote+" for 3rd variable")
    #    return
    #  end if
    
    # Set filename
    fname = Instr.upper()+"pbpStatistics.dat"
    
    # Read the concentration spectra file
    Data = np.loadtxt(FilePathString+fname,dtype=float,skiprows=1)

    return Data
#====================================================

def bblack_binary(FilePathString,Rec,DatDims,DatType,FillVal):
    """Read in data from binary files created by Bob Black at NOAA HRD  
  Examination of .txt files or knowledge of the length of files is required
  to create the DatDims array.  More details regarding the data structure 
  of the binary file records are given below.
 INPUT::
  filepathString  = Long string path to binary file to be read
  Rec             = Record number of binary file (0)
  DatDims         = Array dimensioned to shape of data
  DatType         = Type of data in record (e.g. "float")
  FillVal         = Value for missing data
 OUTPUT::
  Data            = Data array containing binary record data
 USAGE::
  DatOut = read_bblack_binary(filepathString,Rec,DatDims,DatType,FillVal)
------------
 NOTES::
 The CIP instrument (2D-C) has a range of 12.5 micron -1.55 mm with 
 0.025 mm resolution.
 The PIP instrument (2D-P) has a range of 0.100-6.4 mm with 0.100 mm resolution

 Data file structure::
  The number of lines (measurements) were determined via the 
  Dyn_20111124I_cip.txt and Dyn_20111124I_pip.txt files, respectively.
  
  The data were saved to Fortran-produced, direct accesss files on a Big
  Endian machine.  
  There are 7 records 256 bytes long consisting of 64 4-byte IEEE 
  Real numbers.  The 64 numbers correspond to the numbers of elements
  in the diode array, and hence are sizing bins.
  
  The number of records is legacy from the older PMS 2D-C/2D-P combination
  system aboard the aircrafts.  They are in the following format:
  Record 1 = Time and other computed parameters (see below)
  Record 2 = PIP Water (empty in CIP file)
  Record 3 = PIP Ice (empty in CIP file)
  Record 4 = PIP Graupel / CIP 
  Record 5 = PIP Needle / CIP 
  Record 6 = CIP Graupel (empty in PIP file)
  Record 7 = CIP Needle (empty in PIP file)

 Number concentrations are in n/Liter

  Record 1 format for :
           CIP file                        PIP file
   1 = YYMMDD                      1 = YYMMDD
   2 = HHMMSS                      2 = HHMMSS
   3 = CIP Rain rate [mm/hr]       3 = PIP Rain rate [mm/hr]
   4 =                             4 = LWC [g/m^3]
   5 = CIP IWC                     5 = IWC [g/m^3]
   6 =                             6 = PIP dBZ
   7 = Attenuation [dBZ/km]        7 = Attenuation [dBZ/km]
   8 =                             8 = 
   9 =                             9 = 
  10 =                            10 = Repeat of 4
  11 =                            11 = Repeat of 5
  12 = CIP LWC                    12 = 
  13 = Repeat of 5?               13 = 
  14 = CIP svol [l]               14 = 
  15 =                            15 = 
  16 = Repeat of 3                16 = 
  17 =                            17 = Repeat of 3
  18 =                            18 = 
  19 = CIP dBZ                    19 = 
  20 =                            20 = 
  21 = VTC                        21 = 
  22 =                            22 = 
  23 =                            23 = 
  24 =                            24 = 
  25 =                            25 = 
  26 =                            26 = 
  27 =                            27 = PIP sumxsa
  28 =                            28 = PIP avexsa
  29 =                            29 = 
  30 =                            30 = 
  31 = YYYY                       31 = YYYY
  32 = RhoI [g/m^3]               32 = RhoI [g/m^3]
  33 = # Accept                   33 = 
  34 = # Reject                   34 = 
  35 = % Accept                   35 = 
  36 = Streakers                  36 = 
  37 = % Small time (elt)         37 = 
  38 = % Zero A                   38 = 
  39 = % Y-gap                    39 = 
  40 = % Long-X On edge           40 = 
  41 = % Incomplete               41 = 
  42 = % Long Time                42 = 
  43 = % X-gap (multiple image)   43 = 
  44 = Air Density [kg m^-3]      44 = Air Density [kg m^-3]*10.
  45 = Vertical wind, w [m/s]     45 = Vertical wind, w [m/s]
  46 = Temp [C]                   46 = Temp [C]
  47 = Pressure [mb]              47 = Pressure [mb]
  48 = Latitude [deg]             48 = Latitude [deg]
  49 = Longitude [deg]            49 = Longitude [deg]
  50 = Wind speed [m/s]           50 = Wind speed [m/s]
  51 = Wind direction [deg]       51 = Wind direction [deg]
  52 = True Air Speed             52 = 
  53 = Elapsed time 2D records    53 = 
  54 =                            54 = 
  55 =                            55 = 
  56 =                            56 = 
  57 =                            57 = 
  58 =                            58 = 
  59 =                            59 = 
  60 =                            60 = 
  61 =                            61 = 
  62 =                            62 = 
  63 =                            63 = 
  64 =                            64 = 
    """
# MODIFICATION HISTORY::
#  18 Jan 2013 - Nick Guy NOAA/NSSL/WRDD, NRC Postdoc
#---------------------------------------------------
# A Python way to read Fortran Direct access binary file
    nRec = 7 # Number of records in binary file
    nDiodes = 64 # Number of bins (diodes in this case

    f = open(FilPathString,'rb') # Open the file
    Data = np.fromfile(f,dtype='>f4',count=-1) # Read in all Big-Endian Data

    nLines = len(Data)/(nRec*nDiodes) # Find the # of lines of data

#    Data = Data.byteswap() #? Needed to swap the bytes - needed here??
    Data = Data.reshape(nLines,nRec,nDiodes) # Reshape the array

#    fileIn = readfortbin.FortranFile

    # Mask the bad data values
    # Convert concentration data from L^-1 to m^-3 (for SI units)
#    Data(:,1:6,:)=Data(:,1:6,:)*1000.
    
#    return Data
#====================================================
